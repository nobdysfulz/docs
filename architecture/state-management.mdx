---
title: "State Management"
description: "React Context for global state, TanStack Query for server state, and local component state"
---

PWRU uses a three-tier state management approach: React Context for global state, TanStack React Query for server state, and local component state for UI concerns.

## State Tiers

### 1. Global State (React Context)

Two context providers supply application-wide state:

#### UserContext

Provides all user-related data. Available via the `useUser()` hook.

```jsx
const {
  user,                    // Current user profile
  marketConfig,            // Market/territory configuration
  agentProfile,            // AI agent profile settings
  preferences,             // User preferences
  onboarding,              // Onboarding completion state
  actions,                 // User's daily/weekly actions (DailyAction[])
  agentConfig,             // Agent configuration
  userAgentSubscription,   // Subscription status and tier
  goals,                   // Business goals (Goal[])
  businessPlan,            // Active business plan
  pulseHistory,            // Historical PULSE scores
  pulseConfig,             // PULSE configuration
  loading,                 // Initial loading flag
  error,                   // Error state
  refreshUserData,         // Manual refresh function
  isSupportChatOpen,       // Support chat visibility
  setSupportChatOpen,      // Toggle support chat
  activeSupportAgent,      // Current support agent type
  setActiveSupportAgent,   // Set support agent
} = useUser();
```

**Key behaviors:**
- Data is fetched once on mount and cached
- `refreshUserData()` triggers a full refetch of all user data
- Loading state blocks the UI until initial data is available
- Error state is displayed as a full-page error message

#### PartnerContext

Provides multi-tenant branding configuration. Available via the `usePartner()` hook.

```jsx
const {
  partner,    // Partner configuration object
  loading,    // Loading state
  setPartner, // Manual override function
} = usePartner();
```

Partner includes:
- `appDisplayName` - Custom app name
- `primaryColor` / `secondaryColor` - Theme colors
- `companyName` - Company branding
- `faviconUrl` - Custom favicon
- `metaDescription` - SEO description

**Caching:** 30-minute stale time, 1-hour cache time. Shares React Query cache with the root Layout to avoid duplicate requests.

### 2. Server State (TanStack React Query)

Page-specific data is managed with React Query for automatic caching, refetching, and synchronization.

#### Common Query Pattern

```jsx
const { data: contacts = [], isLoading } = useQuery({
  queryKey: ['crm-contacts', user?.id],
  queryFn: async () => {
    return await base44.entities.CrmContact.filter({
      userId: user.id
    });
  },
  enabled: !!user?.id,
  staleTime: 2 * 60 * 1000,    // 2 minutes
  gcTime: 10 * 60 * 1000,      // 10 minutes
});
```

#### Key Conventions

| Convention | Standard |
|------------|----------|
| **Query keys** | Always include `user?.id` for user-scoped data |
| **Enabled flag** | Gate on `!!user?.id` to prevent premature fetches |
| **Stale time** | 1-5 minutes for frequently changing data |
| **Cache time** | 10-15 minutes for most data |
| **Default values** | Always provide defaults (e.g., `data: contacts = []`) |
| **Error handling** | `onError` callbacks for query-specific error handling |

#### Mutations

Data modifications use `useMutation` with query invalidation:

```jsx
const mutation = useMutation({
  mutationFn: async (data) => {
    return await base44.entities.CrmContact.update(id, data);
  },
  onSuccess: () => {
    queryClient.invalidateQueries(['crm-contacts']);
  },
});
```

#### Refetch Strategies

- **Window focus**: `refetchOnWindowFocus: true` (default) - Data refreshes when the user returns to the tab
- **Manual refresh**: Pull-to-refresh on mobile, refresh buttons on desktop
- **Query invalidation**: After mutations, related queries are invalidated to trigger refetch

### 3. Local State (Component State)

UI-only state is managed with `useState` and `useReducer`:

- Modal open/close state
- Active tab selection (synced with URL params)
- Form field values
- Filter and search inputs
- Sidebar open/close state
- Loading indicators for async operations

## Custom Hooks

### usePGICData

Manages Intelligence dashboard data:

```jsx
const {
  data,          // { scores, insights, forecast }
  loading,
  error,
  lastRefreshed, // Timestamp of last data fetch
  refreshing,    // Whether a refresh is in progress
  refresh,       // Manual refresh function
} = usePGICData(userId);
```

### useAuth

Provides authentication state from the AuthProvider:

```jsx
const { user, login, logout, isAuthenticated } = useAuth();
```

## Session Cache

The `sessionCache` utility provides in-memory caching with TTL for expensive computations:

```jsx
import { sessionCache } from '@/utils/sessionCache';

// Set with TTL
sessionCache.set('key', value, ttlMs);

// Get (returns null if expired)
const value = sessionCache.get('key');

// Clear
sessionCache.clear('key');
```

Used primarily for:
- AI agent conversation context (`{agentType}_context`)
- PGIC data between tab switches
- Expensive calculations that shouldn't re-run on every render
