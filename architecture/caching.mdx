---
title: "Caching Strategy"
description: "React Query caching, session cache, and data freshness patterns"
---

PWRU implements caching at multiple layers to balance data freshness with performance.

## React Query Caching

### Cache Configuration by Data Type

| Data Type | Stale Time | Cache Time | Refetch on Focus |
|-----------|-----------|------------|-----------------|
| Partner config | 30 min | 60 min | No |
| User profile | On demand | Session | No |
| CRM contacts | 2 min | 10 min | Yes |
| CRM activities | 1 min | 10 min | Yes |
| Goals | 2 min | 10 min | Yes |
| Generated content | 5 min | 15 min | No |
| PGIC scores | Variable | 10 min | No |
| Call logs | 1 min | 5 min | Yes |

### Key Concepts

**Stale Time** - How long data is considered fresh. During this window, React Query serves cached data without refetching.

**Cache Time (gcTime)** - How long inactive data stays in memory. After this period, the cache entry is garbage collected.

**Refetch on Window Focus** - When enabled, data refetches when the user returns to the browser tab. Useful for data that may change while the user is away.

### Query Key Structure

Query keys include user ID for proper cache isolation:

```jsx
// User-scoped query key
queryKey: ['crm-contacts', user?.id]
queryKey: ['goals', user?.id]
queryKey: ['daily-actions', user?.id, dateKey]

// Entity-scoped query key
queryKey: ['partner', partnerId]
queryKey: ['pipeline-stages']
```

### Cache Invalidation

After mutations, related caches are invalidated to trigger refetch:

```jsx
// After creating a new contact
queryClient.invalidateQueries(['crm-contacts']);

// After updating goals
queryClient.invalidateQueries(['goals']);

// After generating content
queryClient.invalidateQueries(['generated-content']);
```

### Shared Cache Keys

The partner configuration uses shared query keys between the root `Layout` and `PartnerContext` to avoid duplicate network requests:

```jsx
// Both components use the same queryKey
queryKey: ['partner', partnerId]
```

## Session Cache

The `sessionCache` utility provides in-memory key-value caching with TTL expiration for data that doesn't need React Query management.

### API

```jsx
import { sessionCache } from '@/utils/sessionCache';

// Store a value with TTL (milliseconds)
sessionCache.set('agent_context', contextData, 5 * 60 * 1000);

// Retrieve (returns null if expired or missing)
const data = sessionCache.get('agent_context');

// Remove a specific key
sessionCache.clear('agent_context');

// Clear all cached data
sessionCache.clearAll();
```

### Use Cases

| Key Pattern | TTL | Purpose |
|-------------|-----|---------|
| `{agentType}_context` | 5 min | AI agent conversation context |
| `pgic_data` | 5 min | PGIC scores between tab switches |
| `goals_insights` | 10 min | Cached AI-generated goal insights |

### Behavior

- Data is stored in memory only (lost on page refresh)
- TTL is checked on read, not on a timer
- No maximum size limit (managed by usage patterns)
- Cleared when switching between AI agents

## Context Provider Caching

### UserContext

User data is fetched once on mount and cached in React state:
- Not managed by React Query
- Refreshed manually via `refreshUserData()`
- Includes user profile, goals, actions, preferences, onboarding state, pulse history
- Persists for the entire session

### PartnerContext

Partner data uses React Query with long cache times:
- 30-minute stale time (partner config rarely changes)
- 60-minute cache time
- Shares cache with root Layout component

## Cache Warming

On application startup:
1. Auth token validated â†’ user profile loaded
2. Partner configuration fetched (or served from cache)
3. UserContext fetches all user data in parallel
4. Page-specific queries fire based on the initial route

## Offline Behavior

PWRU does not currently implement offline caching. All data requires network connectivity. React Query's cache serves as a short-term buffer but does not persist across browser sessions.
